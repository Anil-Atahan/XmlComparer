using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Xml;
using System.Xml.Linq;

namespace XmlComparer.Core
{
    /// <summary>
    /// Serializes and deserializes XML patches to/from XML and JSON formats.
    /// </summary>
    /// <remarks>
    /// <para>The XmlPatchFormatter provides methods for converting <see cref="XmlPatch"/> objects
    /// to and from serialized formats for storage, transmission, and version control.</para>
    /// <para>Supported formats:</para>
    /// <list type="bullet">
    ///   <item><description>XML - Human-readable XML format</description></item>
    ///   <item><description>JSON - Compact JSON format</description></item>
    ///   <item><description>Binary - Compressed binary format (future)</description></item>
    /// </list>
    /// </remarks>
    /// <example>
    /// <code>
    /// // Serialize to XML
    /// string xml = XmlPatchFormatter.SerializeToXml(patch);
    /// File.WriteAllText("changes.patch", xml);
    ///
    /// // Deserialize from XML
    /// string xml = File.ReadAllText("changes.patch");
    /// var patch = XmlPatchFormatter.DeserializeFromXml(xml);
    ///
    /// // Serialize to JSON
    /// string json = XmlPatchFormatter.SerializeToJson(patch);
    ///
    /// // Deserialize from JSON
    /// var patch = XmlPatchFormatter.DeserializeFromJson(json);
    /// </code>
    /// </example>
    /// <seealso cref="XmlPatch"/>
    public static class XmlPatchFormatter
    {
        // XML namespace for patch format
        private const string PatchNamespace = "https://schemas.xmlcomparer.net/patch";

        /// <summary>
        /// Serializes a patch to XML format.
        /// </summary>
        /// <param name="patch">The patch to serialize.</param>
        /// <param name="formatting">The XML formatting options.</param>
        /// <returns>An XML string representation of the patch.</returns>
        public static string SerializeToXml(XmlPatch patch, SaveOptions formatting = SaveOptions.None)
        {
            var root = new XElement(XNamespace.Get(PatchNamespace) + "XmlPatch");

            // Add metadata
            if (!string.IsNullOrEmpty(patch.Id))
                root.Add(new XElement("Id", patch.Id));
            if (!string.IsNullOrEmpty(patch.Title))
                root.Add(new XElement("Title", patch.Title));
            if (!string.IsNullOrEmpty(patch.Description))
                root.Add(new XElement("Description", patch.Description));
            if (!string.IsNullOrEmpty(patch.OriginalFile))
                root.Add(new XElement("OriginalFile", patch.OriginalFile));
            if (!string.IsNullOrEmpty(patch.TargetFile))
                root.Add(new XElement("TargetFile", patch.TargetFile));
            root.Add(new XElement("CreatedAt", patch.CreatedAt.ToString("o")));
            if (!string.IsNullOrEmpty(patch.Author))
                root.Add(new XElement("Author", patch.Author));

            // Add statistics
            var stats = new XElement("Statistics");
            stats.Add(new XElement("TotalChanges", patch.Statistics.TotalChanges));
            stats.Add(new XElement("Additions", patch.Statistics.Additions));
            stats.Add(new XElement("Deletions", patch.Statistics.Deletions));
            stats.Add(new XElement("Replacements", patch.Statistics.Replacements));
            stats.Add(new XElement("Moves", patch.Statistics.Moves));
            root.Add(stats);

            // Add metadata dictionary
            if (patch.Metadata.Count > 0)
            {
                var metadataElement = new XElement("Metadata");
                foreach (var kvp in patch.Metadata)
                {
                    metadataElement.Add(new XElement("Entry",
                        new XAttribute("key", kvp.Key),
                        kvp.Value));
                }
                root.Add(metadataElement);
            }

            // Add operations
            var operationsElement = new XElement("Operations");
            foreach (var operation in patch.Operations)
            {
                operationsElement.Add(SerializeOperation(operation));
            }
            root.Add(operationsElement);

            var doc = new XDocument(
                new XDeclaration("1.0", "utf-8", "yes"),
                new XComment("XML Patch File - Generated by XmlComparer"),
                root
            );

            // Add formatting option for indentation
            if (formatting == SaveOptions.None)
            {
                return doc.ToString();
            }
            else
            {
                var sb = new StringBuilder();
                var settings = new XmlWriterSettings
                {
                    Indent = true,
                    IndentChars = "  ",
                    NewLineOnAttributes = false,
                    OmitXmlDeclaration = false,
                    Encoding = Encoding.UTF8
                };

                using (var writer = XmlWriter.Create(sb, settings))
                {
                    doc.WriteTo(writer);
                }

                return sb.ToString();
            }
        }

        /// <summary>
        /// Serializes a patch operation to XML.
        /// </summary>
        private static XElement SerializeOperation(XmlPatchOperation operation)
        {
            var element = new XElement("Operation",
                new XAttribute("type", operation.Type.ToString()),
                new XAttribute("path", operation.TargetPath)
            );

            if (operation.Position != PatchPosition.End)
            {
                element.Add(new XAttribute("position", operation.Position.ToString()));
            }

            if (!string.IsNullOrEmpty(operation.Content))
            {
                element.Add(new XElement("Content", operation.Content));
            }

            if (!string.IsNullOrEmpty(operation.NewValue))
            {
                element.Add(new XElement("NewValue", operation.NewValue));
            }

            if (!string.IsNullOrEmpty(operation.OldValue))
            {
                element.Add(new XElement("OldValue", operation.OldValue));
            }

            if (!string.IsNullOrEmpty(operation.Condition))
            {
                element.Add(new XElement("Condition", operation.Condition));
            }

            if (operation.LineNumber.HasValue)
            {
                element.Add(new XAttribute("line", operation.LineNumber.Value));
            }

            if (!string.IsNullOrEmpty(operation.Description))
            {
                element.Add(new XElement("Description", operation.Description));
            }

            return element;
        }

        /// <summary>
        /// Deserializes a patch from XML format.
        /// </summary>
        /// <param name="xml">The XML string to deserialize.</param>
        /// <returns>A deserialized XmlPatch.</returns>
        public static XmlPatch DeserializeFromXml(string xml)
        {
            var doc = XDocument.Parse(xml);
            var root = doc.Root;

            if (root == null)
                throw new InvalidOperationException("Invalid patch XML: no root element");

            var patch = new XmlPatch();

            // Read metadata
            var idElement = root.Element("Id");
            if (idElement != null) patch.Id = idElement.Value;

            var titleElement = root.Element("Title");
            if (titleElement != null) patch.Title = titleElement.Value;

            var descriptionElement = root.Element("Description");
            if (descriptionElement != null) patch.Description = descriptionElement.Value;

            var originalFileElement = root.Element("OriginalFile");
            if (originalFileElement != null) patch.OriginalFile = originalFileElement.Value;

            var targetFileElement = root.Element("TargetFile");
            if (targetFileElement != null) patch.TargetFile = targetFileElement.Value;

            var createdAtElement = root.Element("CreatedAt");
            if (createdAtElement != null) patch.CreatedAt = DateTime.Parse(createdAtElement.Value);

            var authorElement = root.Element("Author");
            if (authorElement != null) patch.Author = authorElement.Value;

            // Read metadata
            var metadataElement = root.Element("Metadata");
            if (metadataElement != null)
            {
                foreach (var entry in metadataElement.Elements("Entry"))
                {
                    var key = entry.Attribute("key")?.Value;
                    if (key != null)
                    {
                        patch.Metadata[key] = entry.Value;
                    }
                }
            }

            // Read operations
            var operationsElement = root.Element("Operations");
            if (operationsElement != null)
            {
                foreach (var opElement in operationsElement.Elements("Operation"))
                {
                    patch.Operations.Add(DeserializeOperation(opElement));
                }
            }

            return patch;
        }

        /// <summary>
        /// Deserializes a patch operation from XML.
        /// </summary>
        private static XmlPatchOperation DeserializeOperation(XElement element)
        {
            var typeAttr = element.Attribute("type");
            var pathAttr = element.Attribute("path");

            if (typeAttr == null || pathAttr == null)
                throw new InvalidOperationException("Invalid operation XML: missing type or path");

            var operation = new XmlPatchOperation
            {
#if NETSTANDARD2_0
                Type = (PatchOperationType)Enum.Parse(typeof(PatchOperationType), typeAttr.Value),
#else
                Type = Enum.Parse<PatchOperationType>(typeAttr.Value),
#endif
                TargetPath = pathAttr.Value
            };

            var positionAttr = element.Attribute("position");
            if (positionAttr != null)
            {
#if NETSTANDARD2_0
                operation.Position = (PatchPosition)Enum.Parse(typeof(PatchPosition), positionAttr.Value);
#else
                operation.Position = Enum.Parse<PatchPosition>(positionAttr.Value);
#endif
            }

            var lineAttr = element.Attribute("line");
            if (lineAttr != null)
            {
                operation.LineNumber = int.Parse(lineAttr.Value);
            }

            var contentElement = element.Element("Content");
            if (contentElement != null) operation.Content = contentElement.Value;

            var newValueElement = element.Element("NewValue");
            if (newValueElement != null) operation.NewValue = newValueElement.Value;

            var oldValueElement = element.Element("OldValue");
            if (oldValueElement != null) operation.OldValue = oldValueElement.Value;

            var conditionElement = element.Element("Condition");
            if (conditionElement != null) operation.Condition = conditionElement.Value;

            var descriptionElement = element.Element("Description");
            if (descriptionElement != null) operation.Description = descriptionElement.Value;

            return operation;
        }

        /// <summary>
        /// Serializes a patch to JSON format.
        /// </summary>
        /// <param name="patch">The patch to serialize.</param>
        /// <param name="indented">Whether to indent the JSON output.</param>
        /// <returns>A JSON string representation of the patch.</returns>
        public static string SerializeToJson(XmlPatch patch, bool indented = true)
        {
            var options = new JsonSerializerOptions
            {
                WriteIndented = indented,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            var json = JsonSerializer.Serialize(patch, options);
            return json;
        }

        /// <summary>
        /// Deserializes a patch from JSON format.
        /// </summary>
        /// <param name="json">The JSON string to deserialize.</param>
        /// <returns>A deserialized XmlPatch.</returns>
        public static XmlPatch DeserializeFromJson(string json)
        {
            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };

            var patch = JsonSerializer.Deserialize<XmlPatch>(json, options);
            return patch ?? throw new InvalidOperationException("Failed to deserialize patch from JSON");
        }

        /// <summary>
        /// Serializes a patch to a binary format for compact storage.
        /// </summary>
        /// <param name="patch">The patch to serialize.</param>
        /// <returns>A byte array containing the serialized patch.</returns>
        public static byte[] SerializeToBinary(XmlPatch patch)
        {
            using var ms = new MemoryStream();
            using var writer = new BinaryWriter(ms, Encoding.UTF8);

            // Write header
            writer.Write("XMLPATCH"); // Magic bytes
            writer.Write(1); // Version

            // Write metadata
            writer.Write(patch.Id ?? "");
            writer.Write(patch.Title ?? "");
            writer.Write(patch.Description ?? "");
            writer.Write(patch.OriginalFile ?? "");
            writer.Write(patch.TargetFile ?? "");
            writer.Write(patch.CreatedAt.ToBinary());
            writer.Write(patch.Author ?? "");

            // Write operations count
            writer.Write(patch.Operations.Count);

            // Write operations
            foreach (var op in patch.Operations)
            {
                writer.Write((int)op.Type);
                writer.Write(op.TargetPath ?? "");
                writer.Write(op.Content ?? "");
                writer.Write(op.NewValue ?? "");
                writer.Write(op.OldValue ?? "");
                writer.Write((int)op.Position);
                writer.Write(op.Condition ?? "");
                writer.Write(op.LineNumber ?? -1);
                writer.Write(op.Description ?? "");
            }

            return ms.ToArray();
        }

        /// <summary>
        /// Deserializes a patch from binary format.
        /// </summary>
        /// <param name="data">The byte array to deserialize.</param>
        /// <returns>A deserialized XmlPatch.</returns>
        public static XmlPatch DeserializeFromBinary(byte[] data)
        {
            using var ms = new MemoryStream(data);
            using var reader = new BinaryReader(ms, Encoding.UTF8);

            // Read and verify header
            var magic = reader.ReadString();
            if (magic != "XMLPATCH")
                throw new InvalidOperationException("Invalid patch binary format: bad magic bytes");

            var version = reader.ReadInt32();
            if (version != 1)
                throw new InvalidOperationException($"Unsupported patch version: {version}");

            var patch = new XmlPatch
            {
                Id = reader.ReadString(),
                Title = reader.ReadString(),
                Description = reader.ReadString(),
                OriginalFile = reader.ReadString(),
                TargetFile = reader.ReadString(),
                CreatedAt = DateTime.FromBinary(reader.ReadInt64()),
                Author = reader.ReadString()
            };

            // Read operations
            var opCount = reader.ReadInt32();
            for (int i = 0; i < opCount; i++)
            {
                var op = new XmlPatchOperation
                {
                    Type = (PatchOperationType)reader.ReadInt32(),
                    TargetPath = reader.ReadString(),
                    Content = reader.ReadString(),
                    NewValue = reader.ReadString(),
                    OldValue = reader.ReadString(),
                    Position = (PatchPosition)reader.ReadInt32(),
                    Condition = reader.ReadString(),
                    LineNumber = reader.ReadInt32(),
                    Description = reader.ReadString()
                };
                if (op.LineNumber == -1) op.LineNumber = null;
                patch.Operations.Add(op);
            }

            return patch;
        }

        /// <summary>
        /// Validates a patch XML string without fully deserializing it.
        /// </summary>
        /// <param name="xml">The XML to validate.</param>
        /// <returns>True if the XML is valid, false otherwise.</returns>
        public static bool IsValidPatchXml(string xml)
        {
            try
            {
                var doc = XDocument.Parse(xml);
                var root = doc.Root;
                return root != null && root.Name.LocalName == "XmlPatch";
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Gets a summary of a patch file without fully loading it.
        /// </summary>
        /// <param name="xml">The patch XML.</param>
        /// <returns>A summary string.</returns>
        public static string GetPatchSummary(string xml)
        {
            try
            {
                var doc = XDocument.Parse(xml);
                var root = doc.Root;

                var title = root?.Element("Title")?.Value ?? "Untitled";
                var opCount = root?.Element("Operations")?.Elements("Operation").Count() ?? 0;

                return $"Patch: {title}, {opCount} operations";
            }
            catch
            {
                return "Invalid patch file";
            }
        }
    }
}
